<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stdgpu: stdgpu::unordered_map&lt; Key, T, Hash, KeyEqual &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stdgpu_logo.png" height="70" vspace="5" hspace="5"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber"><font size="5">1.0.0</font></span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classstdgpu_1_1unordered__map.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classstdgpu_1_1unordered__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stdgpu::unordered_map&lt; Key, T, Hash, KeyEqual &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic class similar to std::unordered_map on the GPU.  
 <a href="classstdgpu_1_1unordered__map.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d50d2aeac76b43989cba2bd85e98f48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> = Key</td></tr>
<tr class="separator:a5d50d2aeac76b43989cba2bd85e98f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daadc2c1416912fd9f582b3b4170e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a08daadc2c1416912fd9f582b3b4170e1">mapped_type</a> = T</td></tr>
<tr class="separator:a08daadc2c1416912fd9f582b3b4170e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7888420277bbadb1b3b1407e7944cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> = thrust::pair&lt; const Key, T &gt;</td></tr>
<tr class="separator:aea7888420277bbadb1b3b1407e7944cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632874d8b82342bd023a8610b1532cd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> = <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a></td></tr>
<tr class="separator:a632874d8b82342bd023a8610b1532cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5711c5e67a0c5356742246644c3d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9fb5711c5e67a0c5356742246644c3d5">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="separator:a9fb5711c5e67a0c5356742246644c3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efdefff0cf79f417b26044566e7b0a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a4efdefff0cf79f417b26044566e7b0a7">key_equal</a> = KeyEqual</td></tr>
<tr class="separator:a4efdefff0cf79f417b26044566e7b0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50f6cb1cb475b8d5da01edf11c289c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#af50f6cb1cb475b8d5da01edf11c289c4">hasher</a> = Hash</td></tr>
<tr class="separator:af50f6cb1cb475b8d5da01edf11c289c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50628d953b4e8bedf0b9d7500528d13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#af50628d953b4e8bedf0b9d7500528d13">reference</a> = <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &amp;</td></tr>
<tr class="separator:af50628d953b4e8bedf0b9d7500528d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12754a37d2be22450e24d0c604b5897e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a12754a37d2be22450e24d0c604b5897e">const_reference</a> = const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &amp;</td></tr>
<tr class="separator:a12754a37d2be22450e24d0c604b5897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902a2965946e6f491860ba226090dd31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a902a2965946e6f491860ba226090dd31">pointer</a> = <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> *</td></tr>
<tr class="separator:a902a2965946e6f491860ba226090dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa111e4335c45a46db02d054c5164ddcf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#aa111e4335c45a46db02d054c5164ddcf">const_pointer</a> = const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> *</td></tr>
<tr class="separator:aa111e4335c45a46db02d054c5164ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e8938503b76500c721622dc92ff11a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a> = <a class="el" href="classstdgpu_1_1unordered__map.html#a902a2965946e6f491860ba226090dd31">pointer</a></td></tr>
<tr class="separator:af3e8938503b76500c721622dc92ff11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c653a802158ac2e7606d48e8ba79c90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> = <a class="el" href="classstdgpu_1_1unordered__map.html#aa111e4335c45a46db02d054c5164ddcf">const_pointer</a></td></tr>
<tr class="separator:a9c653a802158ac2e7606d48e8ba79c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae24fbe8818d51f23b3c8f46e2c773db1"><td class="memItemLeft" align="right" valign="top"><a id="ae24fbe8818d51f23b3c8f46e2c773db1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ae24fbe8818d51f23b3c8f46e2c773db1">unordered_map</a> ()=default</td></tr>
<tr class="memdesc:ae24fbe8818d51f23b3c8f46e2c773db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:ae24fbe8818d51f23b3c8f46e2c773db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c5eb901031c7ed65f84e9e7fbf97a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a57c5eb901031c7ed65f84e9e7fbf97a0">valid</a> () const</td></tr>
<tr class="memdesc:a57c5eb901031c7ed65f84e9e7fbf97a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the object is valid.  <a href="#a57c5eb901031c7ed65f84e9e7fbf97a0">More...</a><br /></td></tr>
<tr class="separator:a57c5eb901031c7ed65f84e9e7fbf97a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2fe025ba70e7812eb105bbad0dca92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92">begin</a> ()</td></tr>
<tr class="memdesc:ada2fe025ba70e7812eb105bbad0dca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the begin of the internal value array.  <a href="#ada2fe025ba70e7812eb105bbad0dca92">More...</a><br /></td></tr>
<tr class="separator:ada2fe025ba70e7812eb105bbad0dca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3596cc0d5da09e196958d962ce1ab2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ae3596cc0d5da09e196958d962ce1ab2a">begin</a> () const</td></tr>
<tr class="memdesc:ae3596cc0d5da09e196958d962ce1ab2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the begin of the internal value array.  <a href="#ae3596cc0d5da09e196958d962ce1ab2a">More...</a><br /></td></tr>
<tr class="separator:ae3596cc0d5da09e196958d962ce1ab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da2adc14f9026d38f77996e23de32f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a8da2adc14f9026d38f77996e23de32f7">cbegin</a> () const</td></tr>
<tr class="memdesc:a8da2adc14f9026d38f77996e23de32f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the begin of the internal value array.  <a href="#a8da2adc14f9026d38f77996e23de32f7">More...</a><br /></td></tr>
<tr class="separator:a8da2adc14f9026d38f77996e23de32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7e71efb8e928e36ff4f5368c6040dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd">end</a> ()</td></tr>
<tr class="memdesc:a3e7e71efb8e928e36ff4f5368c6040dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the end of the internal value array.  <a href="#a3e7e71efb8e928e36ff4f5368c6040dd">More...</a><br /></td></tr>
<tr class="separator:a3e7e71efb8e928e36ff4f5368c6040dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0491fa70a120257355327c00b4eb4d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ab0491fa70a120257355327c00b4eb4d2">end</a> () const</td></tr>
<tr class="memdesc:ab0491fa70a120257355327c00b4eb4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the end of the internal value array.  <a href="#ab0491fa70a120257355327c00b4eb4d2">More...</a><br /></td></tr>
<tr class="separator:ab0491fa70a120257355327c00b4eb4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306511261a7cc572a2e5ce72362428ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a306511261a7cc572a2e5ce72362428ff">cend</a> () const</td></tr>
<tr class="memdesc:a306511261a7cc572a2e5ce72362428ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the end of the internal value array.  <a href="#a306511261a7cc572a2e5ce72362428ff">More...</a><br /></td></tr>
<tr class="separator:a306511261a7cc572a2e5ce72362428ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2e731afab196959b326fb3b295a478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ranges_8h.html#a6edb8f022d6f451efe8afee6fde97e02">device_indexed_range</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a2b2e731afab196959b326fb3b295a478">device_range</a> () const</td></tr>
<tr class="memdesc:a2b2e731afab196959b326fb3b295a478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a range to the values in the container.  <a href="#a2b2e731afab196959b326fb3b295a478">More...</a><br /></td></tr>
<tr class="separator:a2b2e731afab196959b326fb3b295a478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6890e24e4f0e2ebba1548eac331651c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#af6890e24e4f0e2ebba1548eac331651c">bucket</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:af6890e24e4f0e2ebba1548eac331651c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bucket to which the given key is mapped.  <a href="#af6890e24e4f0e2ebba1548eac331651c">More...</a><br /></td></tr>
<tr class="separator:af6890e24e4f0e2ebba1548eac331651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df81b187d0a4f258eb5d09be765bbc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a4df81b187d0a4f258eb5d09be765bbc5">bucket_size</a> (<a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> n) const</td></tr>
<tr class="memdesc:a4df81b187d0a4f258eb5d09be765bbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the requested container bucket.  <a href="#a4df81b187d0a4f258eb5d09be765bbc5">More...</a><br /></td></tr>
<tr class="separator:a4df81b187d0a4f258eb5d09be765bbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf977b11c327e0da0343f2af3dca802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#afdf977b11c327e0da0343f2af3dca802">count</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:afdf977b11c327e0da0343f2af3dca802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with the given key in the container.  <a href="#afdf977b11c327e0da0343f2af3dca802">More...</a><br /></td></tr>
<tr class="separator:afdf977b11c327e0da0343f2af3dca802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ff79e3823c652da7bdfdfb8dbfdbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#aa66ff79e3823c652da7bdfdfb8dbfdbe">find</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:aa66ff79e3823c652da7bdfdfb8dbfdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given key is stored in the container.  <a href="#aa66ff79e3823c652da7bdfdfb8dbfdbe">More...</a><br /></td></tr>
<tr class="separator:aa66ff79e3823c652da7bdfdfb8dbfdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35dfd603f3fa1dc9b11be4b859f1633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#af35dfd603f3fa1dc9b11be4b859f1633">find</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:af35dfd603f3fa1dc9b11be4b859f1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given key is stored in the container.  <a href="#af35dfd603f3fa1dc9b11be4b859f1633">More...</a><br /></td></tr>
<tr class="separator:af35dfd603f3fa1dc9b11be4b859f1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138757e696f309ba796dd848d844fe0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a138757e696f309ba796dd848d844fe0f">contains</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a138757e696f309ba796dd848d844fe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given key is stored in the container.  <a href="#a138757e696f309ba796dd848d844fe0f">More...</a><br /></td></tr>
<tr class="separator:a138757e696f309ba796dd848d844fe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797f87d84a08f197b01b4de23aef4a5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab797f87d84a08f197b01b4de23aef4a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> thrust::pair&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ab797f87d84a08f197b01b4de23aef4a5">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab797f87d84a08f197b01b4de23aef4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given value into the container.  <a href="#ab797f87d84a08f197b01b4de23aef4a5">More...</a><br /></td></tr>
<tr class="separator:ab797f87d84a08f197b01b4de23aef4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c1a1f6f908fbc4d297c9dddb061b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> thrust::pair&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#aae6c1a1f6f908fbc4d297c9dddb061b9">insert</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:aae6c1a1f6f908fbc4d297c9dddb061b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given value into the container.  <a href="#aae6c1a1f6f908fbc4d297c9dddb061b9">More...</a><br /></td></tr>
<tr class="separator:aae6c1a1f6f908fbc4d297c9dddb061b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee17efbdd8d4b52baf68c8dd308963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9dee17efbdd8d4b52baf68c8dd308963">insert</a> (<a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92">begin</a>, <a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd">end</a>)</td></tr>
<tr class="memdesc:a9dee17efbdd8d4b52baf68c8dd308963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given range of elements into the container.  <a href="#a9dee17efbdd8d4b52baf68c8dd308963">More...</a><br /></td></tr>
<tr class="separator:a9dee17efbdd8d4b52baf68c8dd308963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c29af575b0a65cb567c92bbb2f01750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a2c29af575b0a65cb567c92bbb2f01750">insert</a> (<a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92">begin</a>, <a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd">end</a>)</td></tr>
<tr class="memdesc:a2c29af575b0a65cb567c92bbb2f01750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given range of elements into the container.  <a href="#a2c29af575b0a65cb567c92bbb2f01750">More...</a><br /></td></tr>
<tr class="separator:a2c29af575b0a65cb567c92bbb2f01750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7f89a60420bace1e41b4f3392f39ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a6e7f89a60420bace1e41b4f3392f39ba">erase</a> (const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a6e7f89a60420bace1e41b4f3392f39ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the value with the given key from the container.  <a href="#a6e7f89a60420bace1e41b4f3392f39ba">More...</a><br /></td></tr>
<tr class="separator:a6e7f89a60420bace1e41b4f3392f39ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ce5a890e789fc3bfa7e529687f573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ae08ce5a890e789fc3bfa7e529687f573">erase</a> (<a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92">begin</a>, <a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd">end</a>)</td></tr>
<tr class="memdesc:ae08ce5a890e789fc3bfa7e529687f573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the values with the given range of keys from the container.  <a href="#ae08ce5a890e789fc3bfa7e529687f573">More...</a><br /></td></tr>
<tr class="separator:ae08ce5a890e789fc3bfa7e529687f573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472060fc771b4bcf641dc66adf6af2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a472060fc771b4bcf641dc66adf6af2e0">erase</a> (<a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92">begin</a>, <a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt; <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd">end</a>)</td></tr>
<tr class="memdesc:a472060fc771b4bcf641dc66adf6af2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the values with the given range of keys from the container.  <a href="#a472060fc771b4bcf641dc66adf6af2e0">More...</a><br /></td></tr>
<tr class="separator:a472060fc771b4bcf641dc66adf6af2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8bd1042c5adaad1dca994c9f261a00"><td class="memItemLeft" align="right" valign="top"><a id="afb8bd1042c5adaad1dca994c9f261a00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#afb8bd1042c5adaad1dca994c9f261a00">clear</a> ()</td></tr>
<tr class="memdesc:afb8bd1042c5adaad1dca994c9f261a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the complete object. <br /></td></tr>
<tr class="separator:afb8bd1042c5adaad1dca994c9f261a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501ff60cd8188de1c9755f3c650b699e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attribute_8h.html#a0e6438a52b3bb978eba50ba08fbc5876">STDGPU_NODISCARD</a> <a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a501ff60cd8188de1c9755f3c650b699e">empty</a> () const</td></tr>
<tr class="memdesc:a501ff60cd8188de1c9755f3c650b699e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the object is empty.  <a href="#a501ff60cd8188de1c9755f3c650b699e">More...</a><br /></td></tr>
<tr class="separator:a501ff60cd8188de1c9755f3c650b699e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb870287100d7627ecb9e4d325b395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a15eb870287100d7627ecb9e4d325b395">full</a> () const</td></tr>
<tr class="memdesc:a15eb870287100d7627ecb9e4d325b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the object is full.  <a href="#a15eb870287100d7627ecb9e4d325b395">More...</a><br /></td></tr>
<tr class="separator:a15eb870287100d7627ecb9e4d325b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a91018199282fcbc92c74cfb016a9dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a2a91018199282fcbc92c74cfb016a9dc">size</a> () const</td></tr>
<tr class="memdesc:a2a91018199282fcbc92c74cfb016a9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size.  <a href="#a2a91018199282fcbc92c74cfb016a9dc">More...</a><br /></td></tr>
<tr class="separator:a2a91018199282fcbc92c74cfb016a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deb7e31c1756667154cc915edc5d251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a2deb7e31c1756667154cc915edc5d251">max_size</a> () const</td></tr>
<tr class="memdesc:a2deb7e31c1756667154cc915edc5d251"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size.  <a href="#a2deb7e31c1756667154cc915edc5d251">More...</a><br /></td></tr>
<tr class="separator:a2deb7e31c1756667154cc915edc5d251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42213b821a9317be97d94eeb410d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#aba42213b821a9317be97d94eeb410d81">bucket_count</a> () const</td></tr>
<tr class="memdesc:aba42213b821a9317be97d94eeb410d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bucket count.  <a href="#aba42213b821a9317be97d94eeb410d81">More...</a><br /></td></tr>
<tr class="separator:aba42213b821a9317be97d94eeb410d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb92bb140577e42e1ab1a737226c0f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9cb92bb140577e42e1ab1a737226c0f4">excess_count</a> () const</td></tr>
<tr class="memdesc:a9cb92bb140577e42e1ab1a737226c0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The excess count.  <a href="#a9cb92bb140577e42e1ab1a737226c0f4">More...</a><br /></td></tr>
<tr class="separator:a9cb92bb140577e42e1ab1a737226c0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a6e3f0ebbd1f4ae4263bc40b2f33e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9d8a6e3f0ebbd1f4ae4263bc40b2f33e">total_count</a> () const</td></tr>
<tr class="memdesc:a9d8a6e3f0ebbd1f4ae4263bc40b2f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total count.  <a href="#a9d8a6e3f0ebbd1f4ae4263bc40b2f33e">More...</a><br /></td></tr>
<tr class="separator:a9d8a6e3f0ebbd1f4ae4263bc40b2f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124445352adb7c375b7fce1c3265851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a9124445352adb7c375b7fce1c3265851">load_factor</a> () const</td></tr>
<tr class="memdesc:a9124445352adb7c375b7fce1c3265851"><td class="mdescLeft">&#160;</td><td class="mdescRight">The average number of elements per bucket.  <a href="#a9124445352adb7c375b7fce1c3265851">More...</a><br /></td></tr>
<tr class="separator:a9124445352adb7c375b7fce1c3265851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12700187bd1383f4b815dc4e776c96b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af50f6cb1cb475b8d5da01edf11c289c4">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#ab12700187bd1383f4b815dc4e776c96b">hash_function</a> () const</td></tr>
<tr class="memdesc:ab12700187bd1383f4b815dc4e776c96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The hash function.  <a href="#ab12700187bd1383f4b815dc4e776c96b">More...</a><br /></td></tr>
<tr class="separator:ab12700187bd1383f4b815dc4e776c96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f9973b401d65b40d3945d7f917ee1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a4efdefff0cf79f417b26044566e7b0a7">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a66f9973b401d65b40d3945d7f917ee1e">key_eq</a> () const</td></tr>
<tr class="memdesc:a66f9973b401d65b40d3945d7f917ee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key comparator for key equality.  <a href="#a66f9973b401d65b40d3945d7f917ee1e">More...</a><br /></td></tr>
<tr class="separator:a66f9973b401d65b40d3945d7f917ee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c2aa2d607e316c814520df87c718514"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstdgpu_1_1unordered__map.html">unordered_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a7c2aa2d607e316c814520df87c718514">createDeviceObject</a> (const <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> &amp;<a class="el" href="classstdgpu_1_1unordered__map.html#aba42213b821a9317be97d94eeb410d81">bucket_count</a>, const <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> &amp;<a class="el" href="classstdgpu_1_1unordered__map.html#a9cb92bb140577e42e1ab1a737226c0f4">excess_count</a>)</td></tr>
<tr class="memdesc:a7c2aa2d607e316c814520df87c718514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of this class on the GPU (device)  <a href="#a7c2aa2d607e316c814520df87c718514">More...</a><br /></td></tr>
<tr class="separator:a7c2aa2d607e316c814520df87c718514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b887419b1143a13d9153e481b1bd27f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstdgpu_1_1unordered__map.html#a4b887419b1143a13d9153e481b1bd27f">destroyDeviceObject</a> (<a class="el" href="classstdgpu_1_1unordered__map.html">unordered_map</a> &amp;device_object)</td></tr>
<tr class="memdesc:a4b887419b1143a13d9153e481b1bd27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given object of this class on the GPU (device)  <a href="#a4b887419b1143a13d9153e481b1bd27f">More...</a><br /></td></tr>
<tr class="separator:a4b887419b1143a13d9153e481b1bd27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename Hash, typename KeyEqual&gt;<br />
class stdgpu::unordered_map&lt; Key, T, Hash, KeyEqual &gt;</h3>

<p>A generic class similar to std::unordered_map on the GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The key type </td></tr>
    <tr><td class="paramname">T</td><td>The mapped type </td></tr>
    <tr><td class="paramname">Hash</td><td>The type of the hash functor </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>The type of the key equality functor</td></tr>
  </table>
  </dd>
</dl>
<p>Differences to std::unordered_map:</p><ul>
<li>index_type instead of size_type</li>
<li>Manual allocation and destruction of container required</li>
<li>max_size and capacity limited to initially allocated size</li>
<li>No guaranteed valid state when reaching capacity limit</li>
<li>Additional non-standard capacity functions <a class="el" href="classstdgpu_1_1unordered__map.html#a15eb870287100d7627ecb9e4d325b395" title="Checks if the object is full. ">full()</a> and <a class="el" href="classstdgpu_1_1unordered__map.html#a57c5eb901031c7ed65f84e9e7fbf97a0" title="Checks if the object is valid. ">valid()</a></li>
<li>Some member functions missing</li>
<li>Iterators may point at non-occupied and non-valid hash entry</li>
<li>Difference between <a class="el" href="classstdgpu_1_1unordered__map.html#ada2fe025ba70e7812eb105bbad0dca92" title="An iterator to the begin of the internal value array. ">begin()</a> and <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> returns <a class="el" href="classstdgpu_1_1unordered__map.html#a2deb7e31c1756667154cc915edc5d251" title="The maximum size. ">max_size()</a> rather than <a class="el" href="classstdgpu_1_1unordered__map.html#a2a91018199282fcbc92c74cfb016a9dc" title="The size. ">size()</a></li>
<li>Insert function returns iterator to <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> rather than to the element preventing insertion</li>
<li>Range insert and erase functions use iterators to value_type and key_type </li>
</ul>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00077">77</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9c653a802158ac2e7606d48e8ba79c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c653a802158ac2e7606d48e8ba79c90">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> =  <a class="el" href="classstdgpu_1_1unordered__map.html#aa111e4335c45a46db02d054c5164ddcf">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const_pointer </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00095">95</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="aa111e4335c45a46db02d054c5164ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa111e4335c45a46db02d054c5164ddcf">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#aa111e4335c45a46db02d054c5164ddcf">const_pointer</a> =  const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const value_type* </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00093">93</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a12754a37d2be22450e24d0c604b5897e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12754a37d2be22450e24d0c604b5897e">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a12754a37d2be22450e24d0c604b5897e">const_reference</a> =  const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const value_type&amp; </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00091">91</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a9fb5711c5e67a0c5356742246644c3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb5711c5e67a0c5356742246644c3d5">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a9fb5711c5e67a0c5356742246644c3d5">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>std::ptrdiff_t </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00085">85</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="af50f6cb1cb475b8d5da01edf11c289c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50f6cb1cb475b8d5da01edf11c289c4">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#af50f6cb1cb475b8d5da01edf11c289c4">hasher</a> =  Hash</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hash </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00088">88</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a632874d8b82342bd023a8610b1532cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632874d8b82342bd023a8610b1532cd6">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> =  <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>index_t </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00084">84</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="af3e8938503b76500c721622dc92ff11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e8938503b76500c721622dc92ff11a">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a> =  <a class="el" href="classstdgpu_1_1unordered__map.html#a902a2965946e6f491860ba226090dd31">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00094">94</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a4efdefff0cf79f417b26044566e7b0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efdefff0cf79f417b26044566e7b0a7">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a4efdefff0cf79f417b26044566e7b0a7">key_equal</a> =  KeyEqual</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>KeyEqual </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00087">87</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a5d50d2aeac76b43989cba2bd85e98f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d50d2aeac76b43989cba2bd85e98f48">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> =  Key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Key </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00080">80</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a08daadc2c1416912fd9f582b3b4170e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daadc2c1416912fd9f582b3b4170e1">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a08daadc2c1416912fd9f582b3b4170e1">mapped_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>T </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00081">81</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="a902a2965946e6f491860ba226090dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902a2965946e6f491860ba226090dd31">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#a902a2965946e6f491860ba226090dd31">pointer</a> =  <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>value_type* </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00092">92</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="af50628d953b4e8bedf0b9d7500528d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50628d953b4e8bedf0b9d7500528d13">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#af50628d953b4e8bedf0b9d7500528d13">reference</a> =  <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>value_type&amp; </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00090">90</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<a id="aea7888420277bbadb1b3b1407e7944cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7888420277bbadb1b3b1407e7944cd">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> =  thrust::pair&lt;const Key, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>thrust::pair&lt;const Key, T&gt; </p>

<p class="definition">Definition at line <a class="el" href="unordered__map_8cuh_source.html#l00082">82</a> of file <a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada2fe025ba70e7812eb105bbad0dca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2fe025ba70e7812eb105bbad0dca92">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the begin of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the begin of the object </dd></dl>

</div>
</div>
<a id="ae3596cc0d5da09e196958d962ce1ab2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3596cc0d5da09e196958d962ce1ab2a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the begin of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the begin of the object </dd></dl>

</div>
</div>
<a id="af6890e24e4f0e2ebba1548eac331651c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6890e24e4f0e2ebba1548eac331651c">&#9670;&nbsp;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bucket to which the given key is mapped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bucket of the key </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>result &lt; <a class="el" href="classstdgpu_1_1unordered__map.html#aba42213b821a9317be97d94eeb410d81" title="The bucket count. ">bucket_count()</a> </dd></dl>

</div>
</div>
<a id="aba42213b821a9317be97d94eeb410d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba42213b821a9317be97d94eeb410d81">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bucket count. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bucket entries </dd></dl>

</div>
</div>
<a id="a4df81b187d0a4f258eb5d09be765bbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df81b187d0a4f258eb5d09be765bbc5">&#9670;&nbsp;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the requested container bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The bucket index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the requested bucket </dd></dl>

</div>
</div>
<a id="a8da2adc14f9026d38f77996e23de32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da2adc14f9026d38f77996e23de32f7">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the begin of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the begin of the object </dd></dl>

</div>
</div>
<a id="a306511261a7cc572a2e5ce72362428ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306511261a7cc572a2e5ce72362428ff">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the end of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the object </dd></dl>

</div>
</div>
<a id="a138757e696f309ba796dd848d844fe0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138757e696f309ba796dd848d844fe0f">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> bool <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given key is stored in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested key was found, false otherwise </dd></dl>

</div>
</div>
<a id="afdf977b11c327e0da0343f2af3dca802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf977b11c327e0da0343f2af3dca802">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements with the given key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with the given key, i.e. 1 or 0 </dd></dl>

</div>
</div>
<a id="a7c2aa2d607e316c814520df87c718514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2aa2d607e316c814520df87c718514">&#9670;&nbsp;</a></span>createDeviceObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classstdgpu_1_1unordered__map.html">unordered_map</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::createDeviceObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> &amp;&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> &amp;&#160;</td>
          <td class="paramname"><em>excess_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of this class on the GPU (device) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bucket_count</td><td>The number of buckets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess_count</td><td>The number of excess entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>bucket_count &gt; 0 </dd>
<dd>
excess_count &gt; 0 </dd>
<dd>
ispow2(bucket_count) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created object of this class allocated on the GPU (device) </dd></dl>

</div>
</div>
<a id="a4b887419b1143a13d9153e481b1bd27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b887419b1143a13d9153e481b1bd27f">&#9670;&nbsp;</a></span>destroyDeviceObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::destroyDeviceObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstdgpu_1_1unordered__map.html">unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt; &amp;&#160;</td>
          <td class="paramname"><em>device_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the given object of this class on the GPU (device) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device_object</td><td>The object allocated on the GPU (device) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2e731afab196959b326fb3b295a478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2e731afab196959b326fb3b295a478">&#9670;&nbsp;</a></span>device_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ranges_8h.html#a6edb8f022d6f451efe8afee6fde97e02">device_indexed_range</a>&lt;const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a>&gt; <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::<a class="el" href="classstdgpu_1_1device__range.html">device_range</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a range to the values in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>A range of the container </dd></dl>

</div>
</div>
<a id="ab797f87d84a08f197b01b4de23aef4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab797f87d84a08f197b01b4de23aef4a5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> thrust::pair&lt;<a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>, bool&gt; <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given value into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments to construct the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted pair and true if the insertion was successful, <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> and false otherwise </dd></dl>

</div>
</div>
<a id="a501ff60cd8188de1c9755f3c650b699e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501ff60cd8188de1c9755f3c650b699e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attribute_8h.html#a0e6438a52b3bb978eba50ba08fbc5876">STDGPU_NODISCARD</a> <a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> bool <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the object is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the object is empty, false otherwise </dd></dl>

</div>
</div>
<a id="a3e7e71efb8e928e36ff4f5368c6040dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7e71efb8e928e36ff4f5368c6040dd">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the end of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the object </dd></dl>

</div>
</div>
<a id="ab0491fa70a120257355327c00b4eb4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0491fa70a120257355327c00b4eb4d2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An iterator to the end of the internal value array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the object </dd></dl>

</div>
</div>
<a id="a6e7f89a60420bace1e41b4f3392f39ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f89a60420bace1e41b4f3392f39ba">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a632874d8b82342bd023a8610b1532cd6">index_type</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the value with the given key from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there was a value with key and it got erased, 0 otherwise </dd></dl>

</div>
</div>
<a id="ae08ce5a890e789fc3bfa7e529687f573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08ce5a890e789fc3bfa7e529687f573">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the values with the given range of keys from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The begin of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472060fc771b4bcf641dc66adf6af2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472060fc771b4bcf641dc66adf6af2e0">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the values with the given range of keys from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The begin of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb92bb140577e42e1ab1a737226c0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb92bb140577e42e1ab1a737226c0f4">&#9670;&nbsp;</a></span>excess_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::excess_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The excess count. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of excess entries for handling collisions </dd></dl>

</div>
</div>
<a id="aa66ff79e3823c652da7bdfdfb8dbfdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66ff79e3823c652da7bdfdfb8dbfdbe">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given key is stored in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the position of the requested key if it was found, <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> otherwise </dd></dl>

</div>
</div>
<a id="af35dfd603f3fa1dc9b11be4b859f1633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35dfd603f3fa1dc9b11be4b859f1633">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a9c653a802158ac2e7606d48e8ba79c90">const_iterator</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#a5d50d2aeac76b43989cba2bd85e98f48">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given key is stored in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the position of the requested key if it was found, <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> otherwise </dd></dl>

</div>
</div>
<a id="a15eb870287100d7627ecb9e4d325b395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb870287100d7627ecb9e4d325b395">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> bool <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the object is full. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the object is full, false otherwise </dd></dl>

</div>
</div>
<a id="ab12700187bd1383f4b815dc4e776c96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12700187bd1383f4b815dc4e776c96b">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#af50f6cb1cb475b8d5da01edf11c289c4">hasher</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The hash function. </p>
<dl class="section return"><dt>Returns</dt><dd>The hash function </dd></dl>

</div>
</div>
<a id="aae6c1a1f6f908fbc4d297c9dddb061b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6c1a1f6f908fbc4d297c9dddb061b9">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab8084fc28d209ef9401c4b10f21fa24f">STDGPU_DEVICE_ONLY</a> thrust::pair&lt;<a class="el" href="classstdgpu_1_1unordered__map.html#af3e8938503b76500c721622dc92ff11a">iterator</a>, bool&gt; <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given value into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted pair and true if the insertion was successful, <a class="el" href="classstdgpu_1_1unordered__map.html#a3e7e71efb8e928e36ff4f5368c6040dd" title="An iterator to the end of the internal value array. ">end()</a> and false otherwise </dd></dl>

</div>
</div>
<a id="a9dee17efbdd8d4b52baf68c8dd308963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee17efbdd8d4b52baf68c8dd308963">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given range of elements into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The begin of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c29af575b0a65cb567c92bbb2f01750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c29af575b0a65cb567c92bbb2f01750">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iterator_8h.html#a1d2156e646cd66754318ef226fd4c391">device_ptr</a>&lt; const <a class="el" href="classstdgpu_1_1unordered__map.html#aea7888420277bbadb1b3b1407e7944cd">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given range of elements into the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The begin of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66f9973b401d65b40d3945d7f917ee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f9973b401d65b40d3945d7f917ee1e">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="classstdgpu_1_1unordered__map.html#a4efdefff0cf79f417b26044566e7b0a7">key_equal</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The key comparator for key equality. </p>
<dl class="section return"><dt>Returns</dt><dd>The key comparator for key equality </dd></dl>

</div>
</div>
<a id="a9124445352adb7c375b7fce1c3265851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124445352adb7c375b7fce1c3265851">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> float <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The average number of elements per bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>The average number of elements per bucket </dd></dl>

</div>
</div>
<a id="a2deb7e31c1756667154cc915edc5d251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2deb7e31c1756667154cc915edc5d251">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum size. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum size </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to <a class="el" href="classstdgpu_1_1unordered__map.html#a9d8a6e3f0ebbd1f4ae4263bc40b2f33e" title="The total count. ">total_count()</a> </dd></dl>

</div>
</div>
<a id="a2a91018199282fcbc92c74cfb016a9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a91018199282fcbc92c74cfb016a9dc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the object </dd></dl>

</div>
</div>
<a id="a9d8a6e3f0ebbd1f4ae4263bc40b2f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8a6e3f0ebbd1f4ae4263bc40b2f33e">&#9670;&nbsp;</a></span>total_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#ab6e41d965f54b8f40fdd4cc553ddf313">STDGPU_HOST_DEVICE</a> <a class="el" href="cstddef_8h.html#ab7d7736cf297f156865dc68630727f2f">index_t</a> <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::total_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total count. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of entries </dd></dl>

</div>
</div>
<a id="a57c5eb901031c7ed65f84e9e7fbf97a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c5eb901031c7ed65f84e9e7fbf97a0">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash , typename KeyEqual &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstdgpu_1_1unordered__map.html">stdgpu::unordered_map</a>&lt; Key, T, Hash, KeyEqual &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the object is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the state is valid, false otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>stdgpu/<a class="el" href="unordered__map_8cuh_source.html">unordered_map.cuh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
</body>
</html>
