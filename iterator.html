<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stdgpu: Iterating over arrays and containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stdgpu_logo.png" height="70" vspace="5" hspace="5"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber"><font size="5">1.0.0</font></span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('iterator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Iterating over arrays and containers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="iterator_overview"></a>
Motivation</h1>
<p>The iterator concept is one of the core aspects of the Standard Template Library (STL). Most C++ programmers are familiar with this concept and can easily write algorithms with it. The thrust library aims to provide the STL functionality also for device arrays and vectors. This includes the convenient iterator syntax. Consider the following STL example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algortihm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::vector&lt;float&gt; vector(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">std::sort(vector.begin(), vector.end());            <span class="comment">// C++98</span></div><div class="line">std::sort(std::begin(vector), std::end(vector));    <span class="comment">// C++11</span></div></div><!-- fragment --><p>In modern C++, the latter more recent version of begin and end should be used. Semantically, they are identical. thrust provides a similar syntax for its containers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/device_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div><div class="line"></div><div class="line">thrust::device_vector&lt;float&gt; device_vector(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">thrust::sort(thrust::device, vector.begin(), vector.end());</div></div><!-- fragment --><p>The differences to the STL are mostly related to the more generic setting. Although thrust is able to automatically infer whether the vector is allocated on the host or device, it is advisable to clearly state that sorting should be done on the device.</p>
<p>It is also possible to pass raw pointers to thrust algorithms, but the syntax gets intrusive:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/device_ptr.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_array = createDeviceArray&lt;float&gt;(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">thrust::sort(thrust::device, thrust::device_pointer_cast(device_array), thrust::device_pointer_cast(device_array + 1000));</div><div class="line"></div><div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div></div><!-- fragment --><p>The intent of casting to the thrust API is clear, but very verbose. Furthermore, the size of the array must be known and explicitly stated to compute the iterator pointing to the end of the array.</p>
<h1><a class="anchor" id="iterator_api"></a>
Iterator API</h1>
<p>Similar to what the memory managemente API provides (see <a class="el" href="memory.html">Memory management</a>), there is also an API to avoid boilerplate code such as in the example above. It can be considered as a natural extension to how thrust and STL perform in C++11:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/sort.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">stdgpu/iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_array = createDeviceArray&lt;float&gt;(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">thrust::sort(stdgpu::device_begin(device_array), stdgpu::device_end(device_array));</div><div class="line"></div><div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div></div><!-- fragment --><p>Compare this systax to the C++11 version of the STL call. This becomes possible by the internal leak check which now provides the required size information. Therefore, stdgpu::device_end can query the size of the given array and return a pointer to the end. Furthermore, the functions check whether the array is allocated on the host or device to avoid mismatches. Iterators are defined for both host and device arrays. In addition, the const versions of them are also defined. Consider the following C++14 STL example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algortihm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line">std::vector&lt;float&gt; vector(1000);</div><div class="line">std::vector&lt;float&gt; vector_out(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">std::transform(std::cbegin(vector), std::cend(vector), std::begin(vector_out), std::negate&lt;float&gt;());  <span class="comment">// C++14</span></div></div><!-- fragment --><p>The device version with the memory management API is almost identical:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thrust/transform.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thrust/functional.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8h.html">stdgpu/iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_array     = createDeviceArray&lt;float&gt;(1000);</div><div class="line"><span class="keywordtype">float</span>* device_array_out = createDeviceArray&lt;float&gt;(1000);</div><div class="line"></div><div class="line"><span class="comment">// Fill it with something useful</span></div><div class="line"></div><div class="line">thrust::transform(stdgpu::device_cbegin(device_array), stdgpu::device_cend(device_array), stdgpu::device_begin(device_array_out), thrust::negate&lt;float&gt;());</div><div class="line"></div><div class="line">destroyDeviceArray&lt;float&gt;(device_array);</div><div class="line">destroyDeviceArray&lt;float&gt;(device_array_out);</div></div><!-- fragment --><p>The combination of both the memory management and the iterator API provides a very powerful interface to interact with thrust as well as kernels in a fast, safe and intuitive way. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
</body>
</html>
