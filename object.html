<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stdgpu: Container objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stdgpu_logo.png" height="70" vspace="5" hspace="5"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber"><font size="5">1.0.0</font></span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('object.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Container objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="object_overview"></a>
Motivation</h1>
<p>In order to bridge the gap between GPU and CPU programming, the memory management API allows to handle arrays in an efficient and reliable way (see <a class="el" href="memory.html">Memory management</a>). However, this is not sufficient even for most projects which require at least one layer hiding all the computations and memory management operations. Therefore, semantically coherent data (e.g. arrays) should be packed together into a class and processed by the public interface of the class. One category of such classes are containers including std::vector. In the context of GPU programming, array-based data structures are prefered and easier to implement. The thrust library for example only provides a thrust::host_vector and thrust::device_vector class because other structures such as std::unordered_map, std::list, etc. are very difficult to port to the GPU without sacrificing some important properties. While the containers defined in this library also have some limitations, they are still easy to use and robust.</p>
<h1><a class="anchor" id="object_api"></a>
Defining host and device container objects</h1>
<p>As mentioned above, a further abstraction layer to simplify data management is needed. This requires another API to avoid boilerplate code and redudancy. So far, host and device arrays has been defined as the generalization of arrays to CPU and GPU memory. Consequently, host device objects now generalize the traditional class objects. Consider the following class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        MyClass()</div><div class="line">        {</div><div class="line">            this-&gt;array = <span class="keyword">nullptr</span>;</div><div class="line">            this-&gt;<a class="code" href="iterator_8h.html#aab6088756ec6a8bff18be58bcbef69eb">size</a> = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        MyClass(<span class="keyword">const</span> <span class="keywordtype">int</span> size)</div><div class="line">        {</div><div class="line">            this-&gt;array = <span class="keyword">new</span> <span class="keywordtype">float</span>[size];</div><div class="line">            this-&gt;size = size;</div><div class="line">        }</div><div class="line"></div><div class="line">        ~MyClass()</div><div class="line">        {</div><div class="line">            <span class="keyword">delete</span>[] array;</div><div class="line">            <a class="code" href="iterator_8h.html#aab6088756ec6a8bff18be58bcbef69eb">size</a> = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <span class="keywordtype">int</span> parameter) <span class="keyword">const</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Do something useful with array</span></div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">float</span>* array;</div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="iterator_8h.html#aab6088756ec6a8bff18be58bcbef69eb">size</a>;</div><div class="line">};</div></div><!-- fragment --><p>It wraps an array of type float including the size and provides some interaction interface through the member function. There are two constructors for this class. The first is simply the default constructor which should set the object to an empty state. The other constructor allocates the array with the given size. Finally, the destructor cleans them up. This design is quite problematic since copy and move constructors are not considered here which can result to double free errors and memory leaks. Furthermore, this design does not scale to the GPU and a new API must be used. Consider this API on the aforementioned example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyHostDeviceObjectClass</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        MyHostDeviceObjectClass()</div><div class="line">        {</div><div class="line">            this-&gt;_array = <span class="keyword">nullptr</span>;</div><div class="line">            this-&gt;_size = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">static</span> MyHostDeviceObjectClass createDeviceObject(<span class="keyword">const</span> <span class="keywordtype">int</span> size)</div><div class="line">        {</div><div class="line">            MyHostDeviceObjectClass result;</div><div class="line"></div><div class="line">            result._array = createDeviceArray&lt;float&gt;(size);</div><div class="line">            result._size = size;</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> result;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> destroyDeviceObject(MyHostDeviceObjectClass&amp; device_object)</div><div class="line">        {</div><div class="line">            destroyDeviceArray&lt;float&gt;(device_object._array);</div><div class="line">            device_object._size = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">static</span> MyHostDeviceObjectClass createHostObject(<span class="keyword">const</span> <span class="keywordtype">int</span> size)</div><div class="line">        {</div><div class="line">            MyHostDeviceObjectClass result;</div><div class="line"></div><div class="line">            result._array = createHostArray&lt;float&gt;(size);</div><div class="line">            result._size = size;</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> result;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> destroyHostObject(MyHostDeviceObjectClass&amp; host_object)</div><div class="line">        {</div><div class="line">            destroyHostArray&lt;float&gt;(host_object._array);</div><div class="line">            host_object._size = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <span class="keywordtype">int</span> parameter) <span class="keyword">const</span></div><div class="line">        {</div><div class="line">            <span class="comment">// Do something useful with array</span></div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">float</span>* _array;</div><div class="line">        <span class="keywordtype">int</span> _size;</div><div class="line">};</div></div><!-- fragment --><p>Note that this interface is very similar to the host device array interface (see <a class="el" href="memory.html">Memory management</a>). An object can now be easily created and destroyed as follows:</p>
<div class="fragment"><div class="line">MyClass device_object = MyClass::createDeviceObject(1000);</div><div class="line">MyClass hoste_object = MyClass::createHostObject(1000);</div><div class="line"></div><div class="line"><span class="comment">// Do something with device_object and host_object</span></div><div class="line"></div><div class="line">MyClass::destroyDeviceObject(device_object);</div><div class="line">MyClass::destroyHostObject(host_object);</div></div><!-- fragment --><p>In order to match the capabilities of the host device arrays, copy functions can defined in the same manner and used as:</p>
<div class="fragment"><div class="line">MyClass device_object = MyClass::createDeviceObject(1000);</div><div class="line"></div><div class="line"><span class="comment">// Do something with device_object</span></div><div class="line"></div><div class="line">MyClass host_object = MyClass::copyCreateDevice2HostObject(device_object);</div><div class="line"></div><div class="line"><span class="comment">// Do something with host_object</span></div><div class="line"></div><div class="line">MyClass::destroyDeviceObject(device_object);</div><div class="line">MyClass::destroyHostObject(host_object);</div></div><!-- fragment --><p>Compared to arrays, an object always knows its size, so it is not necessary to also pass it as a parameter. This design is used to define the containers in this library. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
</body>
</html>
