<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stdgpu: Memory management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stdgpu_logo.png" height="70" vspace="5" hspace="5"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber"><font size="5">1.0.0</font></span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('memory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Memory management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="memory_overview"></a>
Motivation</h1>
<p>Memory management in C and C++ is one of the main aspects a developer should care about. Usually, containers such as std::vector are sufficient for most use cases. However, all these convenient containers are unfortunately not directly supported on the GPU side. There has been some effort to provide a GPU version of the Standard Template Library (STL), but the solutions are still quite limited. For instance, the thrust library (which is delivered with CUDA by default) has the following limitations:</p>
<ul>
<li>There are only CPU (host) and GPU (device) versions of std::vector called thrust::host_vector and thrust::device_vector, but other containers are not present.</li>
<li>It is not possible to directly pass a thrust::device_vector to a kernel.</li>
<li>The automatic garbage collection of thrust::device_vector avoids memory leaks but may lead to unwanted copies and waste of memory bandwidth.</li>
</ul>
<p>Typically, applications involving the GPU are performance critical and should be well optimized. On the other hand, thrust allows to develop code at a fast pace when sticking to their API. Therefore, most developers use raw pointers to achieve maximum performance. The drawback is that this requires a C-like API to allocate and free host and device memory which is quite intrusive and prone to errors.</p>
<h1><a class="anchor" id="memory_api"></a>
Memory API</h1>
<p>In order to solve this problem, a simple and consistent wrapper API around the memory management functions is defined. The goal is to reduce boilerplate code and give the user strong guarantees about the requested operations.</p>
<h2><a class="anchor" id="memory_create_destroy"></a>
Creating and Destroying Arrays</h2>
<p>The simplest operation when dealing with dynamically allocated arrays is to create such an array. This can be done in the following way:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_float_vector = createDeviceArray&lt;float&gt;(1000, 42.0f);</div><div class="line"><span class="keywordtype">float</span>* host_float_vector = createHostArray&lt;float&gt;(1000, 42.0f);</div></div><!-- fragment --><p>Here, two arrays of length 1000 are created, one on the host and one on the device, and filled with the value 42.0f. Compared to traditional C and C++ allocations, these functions guarantee that the allocated memory is initialized with a well-defined state. The value parameter is optional. In case, no value is given, a default constructed object is used, i.e. float() which equals to 0.0f.</p>
<p>When memory is allocated, it must be freed later at some time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define device_float_vector and host_float_vector</span></div><div class="line"></div><div class="line">destroyDeviceArray&lt;float&gt;(device_float_vector);</div><div class="line">destroyHostArray&lt;float&gt;(host_float_vector);</div></div><!-- fragment --><p>Although these functions are a bit more consistent than the usual memory management functions, the additional overhead of defining this wrapper might not be worth the effort. However, there are several more implicit guarantees:</p>
<ul>
<li>If the allocation of an array fails, a warning is printed and a null pointer is returned to the user.</li>
<li>The destroy{Host,Device}Array functions check whether the array is valid, i.e. not a null pointer, and only then free it. Afterwards, it overwrites the freed pointer to a null pointer. This avoids double free errors leads again to a well-defined state.</li>
<li>Internally, a leak checker maintains a list of allocated arrays. If the user forgets to free an array, a warning can be prompted that some memory is leaking, so that the user can fix this problem easily.</li>
</ul>
<h2><a class="anchor" id="memory_copy"></a>
Copying Arrays between Host and Device</h2>
<p>Creating and destroying arrays is only one step to efficiently handle memory. Data usually become available on the host, but should be processed on the device for performance reasons, and in the end stored on the host again. Consequently, copying arrays between the host and the device is necessary. This can be done by:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* host_float_vector;   <span class="comment">// Create this and set some values</span></div><div class="line"><span class="keywordtype">float</span>* device_float_vector; <span class="comment">// Create this</span></div><div class="line"></div><div class="line">copyHost2DeviceArray&lt;float&gt;(host_float_vector, 1000, device_float_vector);</div><div class="line"></div><div class="line"><span class="comment">// Do something useful with device_float_vector</span></div><div class="line"></div><div class="line">copyDevice2HostArray&lt;float&gt;(device_float_vector, 1000, host_float_vector);</div></div><!-- fragment --><p>Here, the first 1000 values of host_float_vector are copyied to device_float_vector and later on vice versa. If the array to which should be copied is not allocated so far, then one can use these functions to unify allocation and copy:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* host_float_vector;   <span class="comment">// Create this and set some values</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_float_vector = copyCreateHost2DeviceArray&lt;float&gt;(host_float_vector, 1000);</div></div><!-- fragment --><p>All of these copy functions share strong guarantees. Having the internal leak checker, the copy functions check if the arrays are indeed allocated on the host or device. This avoids accidental mismatches. Furthermore, the size of the arrays are checked to prevent copying elements out of the allocated bounds of both arrays.</p>
<p>It is very important to note that these guarantees can only be fulfilled if the arrays have been allocated by this API. External arrays or pointers to stack objects can also be used with this API. However, the checks need to be disabled in this situation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory_8h.html">stdgpu/memory.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">float</span> host_value = 42.0f;</div><div class="line"></div><div class="line"><span class="keywordtype">float</span>* device_value_pointer = copyCreateHost2DeviceArray&lt;float&gt;(&amp;host_value, 1, <a class="code" href="memory_8h.html#a498262251e8954f199c8010f08cb79caa6bf6e695293507a237fe65e10a4ba2e8">MemoryCopy::NO_CHECK</a>);</div></div><!-- fragment --><p>Please keep in mind, that if the functions are called in this way, it is then your responsibility to make sure that this operation succeeds. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
</body>
</html>
